CREATE TABLE SALESMAN(
	SALESMAN_ID INT NOT NULL,
	NAME VARCHAR(50) NOT NULL,
	CITY VARCHAR(50) NOT NULL,
	COMMISSION INT,
	PRIMARY KEY(SALESMAN_ID)
)

CREATE TABLE CUSTOMER(
	CUSTOMER_ID INT NOT NULL,
	CUST_NAME VARCHAR(50) NOT NULL,
	CITY VARCHAR(50) NOT NULL,
	GRADE CHAR(1),
	SALESMAN_ID INT,
	PRIMARY KEY(CUSTOMER_ID),
	FOREIGN KEY(SALESMAN_ID) REFERENCES SALESMAN(SALESMAN_ID)
);

CREATE TABLE ORDERS(
	ORD_NO INT NOT NULL,
	PURCHASE_AMOUNT INT NOT NULL,
	ORDER_DATE DATE NOT NULL,
	CUSTOMER_ID INT NOT NULL,
	SALESMAN_ID INT NOT NULL,
	PRIMARY KEY(ORD_NO),
	FOREIGN KEY(CUSTOMER_ID) REFERENCES CUSTOMER(CUSTOMER_ID),
	FOREIGN KEY(SALESMAN_ID) REFERENCES SALESMAN(SALESMAN_ID)
);


INSERT INTO SALESMAN() VALUES(2,'ABC','DEF',140);

INSERT INTO CUSTOMER() VALUES(1,'PER1','CIT1','A',1);

INSERT INTO ORDER() VALUES(1,1231,2002-06-23,1,2);





ABOVE CIT1 AVG

SELECT COUNT(*) 
FROM CUSTOMER
WHERE GRADE > (
		SELECT AVG(GRADE) 
		FROM CUSTOMER 
		WHERE CITY = 'CIT1'
		);



SELECT AVG(GRADE) 
FROM CUSTOMER 
WHERE CITY = 'CITY1';
Consider the following scenario. You have two tables orders and delivered, where the orders table lists all the orders and the delivered table lists orders that have been delivered. You need a list of all the orders that haven’t been delivered yet.

SELECT SALESMAN.NAME,COUNT(CUST_NAME) 
FROM (CUSTOMER INNER JOIN SALESMAN ON CUSTOMER.SALESMAN_ID = SALESMAN.SALESMAN_ID)
GROUP BY CUSTOMER_ID
HAVING COUNT(CUSTOMER_ID)>1;




SELECT SALESMAN.NAME,SALESMAN.SALESMAN_ID,COUNT(CUSTOMER_ID)
FROM (CUSTOMER INNER JOIN SALESMAN ON CUSTOMER.SALESMAN_ID = SALESMAN.SALESMAN_ID)
GROUP BY SALESMAN_ID 
HAVING COUNT(CUSTOMER_ID) > 1;


SELECT *
FROM SALESMAN,CUSTOMER
WHERE SALESMAN.SALESMAN_ID = CUSTOMER.CUSTOMER_ID AND SALESMAN.CITY = CUSTOMER.CITY;






(SELECT SALESMAN_ID,NAME,CITY
FROM SALESMAN,CUSTOMER
WHERE SALESMAN.SALESMAN_ID = CUSTOMER.CUSTOMER_ID AND SALESMAN.CITY = CUSTOMER.CITY)
UNION
(SELECT *
FROM SALESMAN,CUSTOMER
WHERE SALESMAN.SALESMAN_ID = CUSTOMER.CUSTOMER_ID AND SALESMAN.CITY <> CUSTOMER.CITY)




SELECT SALESMAN_ID,MAX(PURCHASE_AMOUNT)
FROM ORDERS
GROUP BY ORDER_DATE;


SELECT B.ORDER_DATE, A.SALESMAN_ID, A.NAME FROM SALESMAN A, ORDERS B
WHERE A.SALESMAN_ID = B.SALESMAN_ID
AND B.PURCHASE_AMT=(SELECT MAX (PURCHASE_AMT)
FROM ORDERS C
WHERE C.ORDER_DATE = B.ORDER_DATE);


CREATE VIEW AS
SELECT * FROM SALESMAN WHERE SALESMAN_ID IN ( SELECT A.SALESMAN_ID FROM ORDERS A WHERE A.PURCHASE_AMOUNT = ( SELECT MAX(B.PURCHASE_AMOUNT) FROM ORDERS B WHERE A.ORDER_DATE = B.ORDER_DATE ));


ALTER TABLE ORDERS MODIFY CONSTRAINT SALESMAN_ID 


SELECT STUDENT.* FROM STUDENT WHERE USN IN ( SELECT CLASS.USN FROM CLASS,SEMSEC WHERE CLASS.SSID = SEMSEC.SSID AND SEMSEC.SEM = 4 AND SEMSEC.SEC = 'C' );



-- Query to calculate the FinalIA for each studenConsider the following scenario. You have two tables orders and delivered, where the orders table lists all the orders and the delivered table lists orders that have been delivered. You need a list of all the orders that haven’t been delivered yet.t
UPDATE IAMARKS 
SET FinalIA = (Test1 + Test2 + Test3 - LEAST(Test1, Test2, Test3)) / 2 
WHERE USN IN (SELECT USN FROM CLASS);

-- Query to view the updated IAMARKS table
SELECT * FROM IAMARKS;


SELECT STUDENT.SNAME,STUDENT.USN,IAMARKS.FINALIA,
	CASE 
    	WHEN IAMARKS.FINALIA BETWEEN 17 AND 20 THEN 'OUT STANDING'
        WHEN IAMARKS.FINALIA BETWEEN 12 AND 16 THEN 'AVERAGE'
        WHEN IAMARKS.FINALIA <12 THEN 'WEAK'
     END AS PERFORMANCE
FROM STUDENT,IAMARKS
WHERE STUDENT.USN = IAMARKS.USN;




SELECT STUDENT.SNAME,STUDENT.USN,IAMARKS.FINALIA,SEMSEC.SEM,SEMSEC.SEC
	CASE 
    	WHEN IAMARKS.FINALIA BETWEEN 17 AND 20 THEN 'OUT STANDING'
        WHEN IAMARKS.FINALIA BETWEEN 12 AND 16 THEN 'AVERAGE'
        WHEN IAMARKS.FINALIA <12 THEN 'WEAK'
    END AS PERFORMANCE
FROM STUDENT,IAMARKS,SEMSEC



SELECT A.SNAME,A.USN,B.FINALIA,C.SEM,C.SEC,
	CASE
		WHEN B.FINALIA BETWEEN 17 AND 20 THEN 'OUT STANDING' 
		WHEN B.FINALIA BETWEEN 12 AND 16 THEN 'AVERAGE' 
		WHEN B.FINALIA <12 THEN 'WEAK' 
	END AS PERFORMANCE 
FROM STUDENT A INNER JOIN IAMARKS B ON A.USN = B.USN INNER JOIN SEMSEC C ON C.SSID = B.SSID 
WHERE C.SEM = 8 AND C.SEC IN ('A','B','C');

ALTER TABLE EMPLOYEE ADD DNO INT NOT NULL FOREIGN KEY REFERENCES DEPARTMENT(DNO);















Consider the following scenario. You have two tables orders and delivered, where the orders table lists all the orders and the delivered table lists orders that have been delivered. You need a list of all the orders that haven’t been delivered yet.




raj raj
6 years ago
Scripts for practice
DROP TABLE T1 CASCADE CONSTRAINTS;
DROP TABLE T2 CASCADE CONSTRAINTS;




(SELECT WORKS_ON.PNO
FROM WORKS_ON,EMPLOYEE
WHERE EMPLOYEE.SSN = WORKS_ON.SSN)

UNION

(SELECT WORKS_ON.PNO 
FROM WORKS_ON,DEPARTMENT
WHERE WORKS_ON.SSN = DEPARTMENT.MGR_SSN
);


(SELECT WORKS_ON.PNO FROM WORKS_ON,EMPLOYEE WHERE EMPLOYEE.SSN = WORKS_ON.SSN AND EMPLOYEE.NAME = 'EMP1') UNION (SELECT WORKS_ON.PNO FROM WORKS_ON,DEPARTMENT,EMPLOYEE WHERE WORKS_ON.SSN = DEPARTMENT.MGR_SSN AND DEPARTMENT.MGR_SSN = EMPLOYEE.SSN AND EMPLOYEE.NAME = 'EMP1' );



SELECT E.ENAME,E.SSN
FROM EMPLOYEE
WHERE NOT EXIST (
	(SELECT PNO 
	FROM PROJECT
	WHERE DNO = 5) MINUS (
		SELECT PNO 
		FROM PNO 
		WHERE E.SSN = SSN
	)

);







